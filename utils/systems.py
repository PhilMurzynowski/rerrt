"""
Dynamics
Using simplified custom system classes
"""
import numpy as np
from pydrake.all import (AutoDiffXd, autoDiffToGradientMatrix, initializeAutoDiff)


class System():

    def __init__(self, sys_opts):
        self.dt = sys_opts['dt']
        self.nx = sys_opts['nx']
        self.nu = sys_opts['nu']
        self.nw = sys_opts['nw']
        self.dir = 1

    def dynamics(self, state, inputs, uncertainty=None):
        raise NotImplementedError('Specify a sublcass with dynamics')

    def nextState(self, state, inputs):
        # wrapper for forwards integration
        if self.dir == -1:
            self.dir = 1
        return self.dynamics(state, inputs)

    def prevState(self, state, inputs):
        # backwards integration
        if self.dir == 1:
            self.dir = -1
        return self.dynamics(state, inputs)

    def simulate(self, state, inputs, num_steps, direction):
        # simulate num_steps with single input
        x = state
        for i in range(num_steps):
            if direction == 'forward':
                x = self.nextState(x, inputs)
            elif direction == 'backward':
                x = self.prevState(x, inputs)
        return x

    def getJacobians(self, x, u, w=None):
        if w is None:
            w = np.zeros((self.nw, 1))
        # format for autodiff
        xuw = np.vstack((x, u, w))
        xuw_autodiff = initializeAutoDiff(xuw)
        # name and split here for readability
        x_autodiff = xuw_autodiff[:self.nx, :]
        u_autodiff = xuw_autodiff[self.nx:self.nx+self.nu, :]
        w_autodiff = xuw_autodiff[self.nx+self.nu:, :]
        x_next_autodiff = self.dynamics(x_autodiff, u_autodiff, w_autodiff)
        # nice function organize for us and return gradient matrix
        x_next_gradient = autoDiffToGradientMatrix(x_next_autodiff)
        # split into Ai, Bi, Gi
        Ai = x_next_gradient[:, 0:self.nx]
        Bi = x_next_gradient[:, self.nx:self.nx+self.nu]
        Gi = x_next_gradient[:, self.nx+self.nu:]
        return Ai, Bi, Gi


class Car(System):


    def dynamics(self, state, inputs, uncertainty=None):
        if uncertainty is None:
            uncertainty = np.zeros((self.nw, 1))
        #["x_pos", "y_pos", "heading", "speed", "steer_angle"]
        x_next = np.array([
            state[0] + self.dir*self.dt*(state[3]*np.cos(state[2])),
            state[1] + self.dir*self.dt*(state[3]*np.sin(state[2])),
            state[2] + self.dir*self.dt*(state[3]*np.tan(state[4] + uncertainty[0])),
            state[3] + self.dir*self.dt*(inputs[0]),
            state[4] + self.dir*self.dt*(inputs[1] + uncertainty[1])])
        return x_next


class Input():
    """
    Object designed to provide RERRT with different input options
    when calculating reachable states from a node. Currently supports
    two types, 'deterministic' and 'random' as they are defined below.
    'deterministic' :   Use all provided possible actions
    'random'        :   Sample random subset of possible actions
    If 'deterministic' is desired:
        Two options:
            1. Pass into setActions all the actions to be used and call it a day
            2. Or have a set of actions generated by calling setLimits and determinePossibleActions
    For 'random':
        Exactly the same as above followed by setting the desired number of samples to be
        tried from these possible actions with setNumSamples
    """


    def __init__(self, dim, type_=None):
        """Initialize, has example default configuration
        dim         integer, dimension of the input excluding the one i.e. nu from (nu x 1)
        """
        self.dim = dim
        if type_ is not None:
            self.setType(type_)
        # default configuration
        elif type_ is None:
            self.setType('deterministic')
            self.setLimits(np.ones(dim))
            self.determinePossibleActions(2*np.ones(dim))

    def setLimits(self, limits):
        assert limits.size == self.dim
        self.limits = limits

    def setType(self, type_):
        """Sets type of input.
        type_       'deterministic'/'random'
        """
        assert type_ == 'deterministic' or type_ == 'random'
        self.type = type_

    def setNumSamples(self, n):
        """Once determinePossibleActions has been called to set all possible actions,
        if input type is random can choose how many actions to sample when calculating
        reachable states. Input type deterministic will always use all provided actions
        """
        assert self.type == 'random'
        self.numsamples = n

    def setActions(self, actions):
        """Set provided actions to possible actions.
        actions     :nparray:   (num_different_actions, dim, 1)
        """
        self.actions = actions

    def determinePossibleActions(self, resolutions):
        """Once limits have been set, pass in resolution at which to generate
        possible actions. Higher resolutions will result in more action combinations.
        e.g.
            For a 1d input, passing in resolutions=np.array([5])
            will result in 5 different actions between -limit and limit.
            For a 2d input, passing in resolutions=np.array([3, 2])
            will create 6 different action combinations, again sampling
            between -limit and limit for each dimension
            limits are described in self.limits
        resolutions     :nparray:   (nu,)
        """
        assert resolutions.size == self.dim
        num_combinations = int(np.prod(resolutions))
        actions = np.zeros((num_combinations, self.dim, 1))
        for idx, r in enumerate(resolutions):
            repeat = int(num_combinations/r)
            tmp = np.tile(np.linspace(-self.limits[idx], self.limits[idx], r), repeat).reshape(num_combinations, 1)
            actions[:, idx, :] = tmp
        self.setActions(actions)
        if self.type == 'deterministic': self.numsamples = num_combinations

    def getAction(self, idx):
        """Obtain one action from self.actions. If deterministic, uses provided idx.
        If random, generates random idx to get action. Returns idx, action pair for
        bookkeeping necessary if using in RERRT reachable state functions.
        """
        if self.type == 'deterministic': return idx, self.actions[idx]
        rand_idx = np.random.randint(low=0, high=len(self.actions))
        return rand_idx, self.actions[rand_idx]


